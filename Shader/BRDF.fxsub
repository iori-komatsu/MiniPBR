#ifndef SHADER_BRDF_INCLUDED
#define SHADER_BRDF_INCLUDED

// 参考文献
//
// * Brian Karis; Epic Games.
//   "Real Shading in Unreal Engine 4".
//   SIGGRAPH 2013 Course: Physically Based Shading in Theory and Practice.
//   https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
//
// * Brent Burley; Walt Disney Animation Studios.
//   "Physically Based Shading at Disney".
//   SIGGRAPH 2012 Course: Practical Physically Based Shading in Film and Game Production.
//   https://www.disneyanimation.com/publications/physically-based-shading-at-disney/
//
// * Yasuhiro Fujii. "A tiny improvement of Oren-Nayar reflectance model".
//   https://mimosa-pudica.net/improved-oren-nayar.html

#include <Shader/Math.fxsub>

// Lambert拡散BRDF
float3 LambertDiffuseBRDF(float3 albedo) {
    return INV_PI * albedo;
}

/*
// Half-Lambert を使った拡散BRDF
// ただし dotNL を掛けて返す。
float3 HalfLambertDiffuseBRDF(float dotNL, float3 albedo) {
    const float invZ = 3.0 / (4.0 * PI);
    float c = dotNL * 0.5 + 0.5;
    return invZ * c * c * albedo;
}
*/

float3 OrenNayarDiffuseBRDF(float3 dotNL, float dotNV, float dotLV, float3 albedo, float roughness) {
    float r2 = sq(roughness);
    float3 A = (1 - 0.5 * r2 / (r2 + 0.33) + 0.17 * albedo * r2 / (r2 + 0.13)) / PI;
    float B = (0.45 * r2 / (r2 + 0.09)) / PI;
    float3 s = dotLV - dotNL * dotNV;
    float3 t = s <= 0 ? 1 : max(dotNL, dotNV);
    return albedo * (A + B*s/t);
}

inline float FifthPower(float x) {
    return x * x * x * x * x;
}

inline float3 FifthPower(float3 x) {
    return x * x * x * x * x;
}

/*
float3 OrenNayarDiffuseBRDF2(float3 dotNL, float dotNV, float dotLV, float dotNH, float3 albedo, float f0, float roughness) {
    // Hammon の近似式
    float3 fSmooth = (21.0/20.0) * (1.0 - f0) * (1.0 - FifthPower(1.0 - dotNL)) * (1.0 - FifthPower(1.0 - dotNV));
    float  kFacing = 0.5 + 0.5 * dotLV;
    float3 fRough  = kFacing * (0.9 - 0.4 * kFacing) * ((0.5 + dotNH) / dotNH);
    float  fMulti  = 0.3641 * roughness;
    return step(0, dotNL) * step(0, dotNV) * (albedo * INV_PI) * (lerp(fSmooth, fRough, roughness) + albedo * fMulti);
}
*/

float SchlickF90(float cosine, float f90) {
    return 1.0 + (f90 - 1.0) * FifthPower(1.0 - saturate(cosine));
}

float3 SchlickF90(float3 cosine, float f90) {
    return 1.0 + (f90 - 1.0) * FifthPower(1.0 - saturate(cosine));
}

float3 DiffuseBRDF(float3 dotNL, float dotNV, float dotLV, float dotLH, float3 albedo, float roughness) {
    // Oren-Nayer と Burley Diffuse を組み合わせる
    float3 base = OrenNayarDiffuseBRDF(dotNL, dotNV, dotLV, albedo, roughness);
    float f90 = 0.5 + 2.0 * sq(dotLH) * roughness;
    return base * SchlickF90(dotNL, f90) * SchlickF90(dotNV, f90);
}

float3 SpecularD(float dotNH, float roughness) {
    float a = sq(roughness);
    return INV_PI * sq(a) / sq(sq(dotNH) * (sq(a) - 1.0) + 1.0);
}

float3 SpecularG(float dotNL, float dotNV, float roughness) {
    // BRDFの分母に dotNL・dotNV の項があり、SpecularG の分子にも dotNL・dotNV の項があるのでキャンセルしておく
    float k = sq(roughness + 1.0) / 8.0;
    float gl = 1 / (dotNL * (1.0 - k) + k);
    float gv = 1 / (dotNV * (1.0 - k) + k);
    return gl * gv;
}

float3 SpecularF(float dotVH, float3 f0) {
    // Schlick の近似
    return f0 + (1.0 - f0) * FifthPower(1.0 - saturate(dotVH));
}

// Cook-Torrance のスペキュラBRDF
// dotNL > 0, dotNV > 0, dotNH > 0 を仮定する。
float3 SpecularBRDF(
    float dotNL,
    float dotNV,
    float dotNH,
    float dotVH,
    float roughness,
    float3 f0
) {
    return 0.25
         * SpecularD(dotNH, roughness)
         * SpecularF(dotVH, f0)
         * SpecularG(dotNL, dotNV, roughness);
}

// Blinn-Phong specular
float3 BlinnPhongSpecular(float dotNH, float3 reflectance, float power) {
    float invZ = (power + 2.0) * (power + 4.0)
               / (8.0 * PI * (exp2(-0.5 * power) + power));
    return invZ * reflectance * pow(saturate(dotNH), power);
}

#endif
