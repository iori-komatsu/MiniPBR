#ifndef SHADER_SHADOW_MAP_INCLUDED
#define SHADER_SHADOW_MAP_INCLUDED

#include <Shader/Parameter/Geometry.fxsub>
#include <Shader/Parameter/Light.fxsub>

static float MaxShadowDepth = 50;
static float LightDistance = 1000;

// ワールド空間の座標をライトから見た座標に変換するための行列を返す。
float4x4 CalculateLightViewMatrix() {
    // TODO: cameraDir と LightDir が平行な場合をケアする
    float3 cameraDir = normalize(ViewMatrix._13_23_33 / ProjectionMatrix._33);
    float3 up = float3(0, 0, 1);
    float3 axisZ = LightDir;
    float3 axisX = normalize(cross(up, axisZ));
    float3 axisY = normalize(cross(axisZ, axisX));

    // 座標軸が (axisX, axisY, axisZ) となるように空間を回転する行列
    float3x3 rotation = transpose(float3x3(axisX, axisY, axisZ));

    float3 origin = -LightDir * LightDistance;

    return float4x4(
        rotation[0], 0,
        rotation[1], 0,
        rotation[2], 0,
        mul(-origin, rotation), 1
    );
}

static float4x4 LightViewMatrix = CalculateLightViewMatrix();
static float4x4 LightViewFromCameraViewMatrix = mul(InverseViewMatrix, LightViewMatrix);

// 視錐台の8つの頂点のカメラビュー座標を返す。
void GetFrustumCornersInCameraViewSpace(float nearZ, float farZ, out float4x4 oNearPlane, out float4x4 oFarPlane) {
    float3 v = float3(
        1 / ProjectionMatrix._11,
        1 / ProjectionMatrix._22,
        1
    );
    const float2 sgn = float2(1, -1);
    oNearPlane = float4x4(
        v * sgn.xxx * nearZ, 1,
        v * sgn.xyx * nearZ, 1,
        v * sgn.yxx * nearZ, 1,
        v * sgn.yyx * nearZ, 1
    );
    oFarPlane = float4x4(
        v * sgn.xxx * farZ, 1,
        v * sgn.xyx * farZ, 1,
        v * sgn.yxx * farZ, 1,
        v * sgn.yyx * farZ, 1
    );
}

// 視錐台の8つの頂点のライトビュー座標を返す。
void GetFrustumCornersInLightViewSpace(float nearZ, float farZ, out float4x4 oNearPlane, out float4x4 oFarPlane) {
    float4x4 nearPlane, farPlane;
    GetFrustumCornersInCameraViewSpace(nearZ, farZ, nearPlane, farPlane);

    oNearPlane = float4x4(
        mul(nearPlane[0], LightViewFromCameraViewMatrix),
        mul(nearPlane[1], LightViewFromCameraViewMatrix),
        mul(nearPlane[2], LightViewFromCameraViewMatrix),
        mul(nearPlane[3], LightViewFromCameraViewMatrix)
    );
    oFarPlane = float4x4(
        mul(farPlane[0],  LightViewFromCameraViewMatrix),
        mul(farPlane[1],  LightViewFromCameraViewMatrix),
        mul(farPlane[2],  LightViewFromCameraViewMatrix),
        mul(farPlane[3],  LightViewFromCameraViewMatrix)
    );
}

float4x4 MatrixOrthoOffCenterLH(
    float minX, float maxX,
    float minY, float maxY,
    float nearZ, float farZ
) {
    // 出典: https://docs.microsoft.com/en-us/windows/win32/direct3d9/d3dxmatrixorthooffcenterlh
    return float4x4(
        2/(maxX-minX), 0, 0, 0,
        0, 2/(maxY-minY), 0, 0,
        0, 0, 1/(farZ-nearZ), 0,
        (minX+maxX)/(minX-maxX), (minY+maxY)/(minY-maxY), nearZ/(nearZ-farZ), 1
    );
}

float4x4 CalculateLightProjectionMatrix() {
    float4x4 nearPlane, farPlane;
    GetFrustumCornersInLightViewSpace(0, MaxShadowDepth, nearPlane, farPlane);

    float2 minCoord = nearPlane[0].xy;
    minCoord = min(minCoord, nearPlane[1].xy);
    minCoord = min(minCoord, nearPlane[2].xy);
    minCoord = min(minCoord, nearPlane[3].xy);
    minCoord = min(minCoord, farPlane[0].xy);
    minCoord = min(minCoord, farPlane[1].xy);
    minCoord = min(minCoord, farPlane[2].xy);
    minCoord = min(minCoord, farPlane[3].xy);

    float2 maxCoord = nearPlane[0].xy;
    maxCoord = max(maxCoord, nearPlane[1].xy);
    maxCoord = max(maxCoord, nearPlane[2].xy);
    maxCoord = max(maxCoord, nearPlane[3].xy);
    maxCoord = max(maxCoord, farPlane[0].xy);
    maxCoord = max(maxCoord, farPlane[1].xy);
    maxCoord = max(maxCoord, farPlane[2].xy);
    maxCoord = max(maxCoord, farPlane[3].xy);

    return MatrixOrthoOffCenterLH(
        minCoord.x, maxCoord.x,
        minCoord.y, maxCoord.y,
        0, 2*LightDistance
    );
}

static float4x4 LightProjectionMatrix = CalculateLightProjectionMatrix();

// シャドウマップを描画する際のクリップ座標を返す。
float4 ShadowMapCoord(float3 worldPos, out float oDepth) {
    float4 viewPos = mul(float4(worldPos, 1), LightViewMatrix);
    oDepth = viewPos.z;
    return mul(viewPos, LightProjectionMatrix);
}

float ShadowBias(float dotNL, float depth) {
    float baseBias = clamp(0.002 * tan(acos(dotNL)), 0.001, 0.01);
    float deltaX = abs(ddx(depth));
    float deltaY = abs(ddy(depth));
	return baseBias * MaxShadowDepth + deltaX + deltaY;
}

#endif
