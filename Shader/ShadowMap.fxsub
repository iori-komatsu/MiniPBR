#ifndef SHADER_SHADOW_MAP_INCLUDED
#define SHADER_SHADOW_MAP_INCLUDED

#include <Shader/Parameter/Geometry.fxsub>
#include <Shader/Parameter/Light.fxsub>

static float MaxShadowDepth = 100;
static float LightDistance = 50;

// ワールド空間の座標をライトから見た座標に変換するための行列を返す。
float4x4 CalculateLightViewMatrix() {
    // TODO: cameraDir と LightDir が平行な場合をケアする
    //float3 cameraDir = normalize(ViewMatrix._13_23_33 / ProjectionMatrix._33);
    float3 up = float3(0, 0, 1);
    float3 axisZ = LightDir;
    float3 axisX = normalize(cross(up, axisZ));
    float3 axisY = normalize(cross(axisZ, axisX));

    // 座標軸が (axisX, axisY, axisZ) となるように空間を回転する行列
    float3x3 rotation = transpose(float3x3(axisX, axisY, axisZ));

    float3 origin = -LightDir * LightDistance;

    return float4x4(
        rotation[0], 0,
        rotation[1], 0,
        rotation[2], 0,
        mul(-origin, rotation), 1
    );
}

static float4x4 LightViewMatrix = CalculateLightViewMatrix();
static float4x4 LightViewFromCameraViewMatrix = mul(InverseViewMatrix, LightViewMatrix);

// 視錐台の8つの頂点のカメラビュー座標を返す。
void GetFrustumCornersInCameraViewSpace(float nearZ, float farZ, out float4x4 oNearPlane, out float4x4 oFarPlane) {
    float p11 = ProjectionMatrix._11;
    float p22 = ProjectionMatrix._22;

    float4 v = float4(1/p11, 1/p22, 1, 1);

    const float2 sgn = float2(-1, 1);
    float4x4 plane = float4x4(
        v * sgn.xxxx,
        v * sgn.xyxx,
        v * sgn.yxxx,
        v * sgn.yyxx
    );

    oNearPlane = plane * nearZ;
    oFarPlane  = plane * farZ;
}

// 視錐台の8つの頂点のライトビュー座標を返す。
void GetFrustumCornersInLightViewSpace(float nearZ, float farZ, out float4x4 oNearPlane, out float4x4 oFarPlane) {
    float4x4 nearPlane, farPlane;
    GetFrustumCornersInCameraViewSpace(nearZ, farZ, nearPlane, farPlane);

    oNearPlane = float4x4(
        mul(nearPlane[0], LightViewFromCameraViewMatrix),
        mul(nearPlane[1], LightViewFromCameraViewMatrix),
        mul(nearPlane[2], LightViewFromCameraViewMatrix),
        mul(nearPlane[3], LightViewFromCameraViewMatrix)
    );
    oFarPlane = float4x4(
        mul(farPlane[0],  LightViewFromCameraViewMatrix),
        mul(farPlane[1],  LightViewFromCameraViewMatrix),
        mul(farPlane[2],  LightViewFromCameraViewMatrix),
        mul(farPlane[3],  LightViewFromCameraViewMatrix)
    );
}

float4x4 MatrixOrthoOffCenterLH(
    float minX, float maxX,
    float minY, float maxY,
    float nearZ, float farZ
) {
    // 出典: https://docs.microsoft.com/en-us/windows/win32/direct3d9/d3dxmatrixorthooffcenterlh
    return float4x4(
        2/(maxX-minX), 0, 0, 0,
        0, 2/(maxY-minY), 0, 0,
        0, 0, 1/(farZ-nearZ), 0,
        (minX+maxX)/(minX-maxX), (minY+maxY)/(minY-maxY), nearZ/(nearZ-farZ), 1
    );
}

float4x4 MatrixOrthoLH(float w, float h, float nearZ, float farZ) {
    return float4x4(
        2/w, 0, 0, 0,
        0, 2/h, 0, 0,
        0, 0, 1/(farZ-nearZ), 0,
        0, 0, nearZ/(nearZ-farZ), 1
    );
}


float4x4 CalculateLightProjectionMatrix() {
    /*
    return float4x4(
        1/30.0,0,0,0,
        0,1/10.0,0,0,
        0,0,1/MaxShadowDepth,0,
        0,0,0,1
    );
    */

    float4x4 nearPlane, farPlane;
    GetFrustumCornersInLightViewSpace(0, MaxShadowDepth, nearPlane, farPlane);

    float2 minCoord = nearPlane[0].xy;
    minCoord = min(minCoord, nearPlane[1].xy);
    minCoord = min(minCoord, nearPlane[2].xy);
    minCoord = min(minCoord, nearPlane[3].xy);
    minCoord = min(minCoord, farPlane[0].xy);
    minCoord = min(minCoord, farPlane[1].xy);
    minCoord = min(minCoord, farPlane[2].xy);
    minCoord = min(minCoord, farPlane[3].xy);

    float2 maxCoord = nearPlane[0].xy;
    maxCoord = max(maxCoord, nearPlane[1].xy);
    maxCoord = max(maxCoord, nearPlane[2].xy);
    maxCoord = max(maxCoord, nearPlane[3].xy);
    maxCoord = max(maxCoord, farPlane[0].xy);
    maxCoord = max(maxCoord, farPlane[1].xy);
    maxCoord = max(maxCoord, farPlane[2].xy);
    maxCoord = max(maxCoord, farPlane[3].xy);

    return MatrixOrthoOffCenterLH(
        minCoord.x, maxCoord.x,
        minCoord.y, maxCoord.y,
        0, MaxShadowDepth
    );
}

static float4x4 LightProjectionMatrix = CalculateLightProjectionMatrix();
static float4x4 LightViewProjectionMatrix = mul(LightViewMatrix, LightProjectionMatrix);

float3 ShadowMapCoord(float3 worldPos) {
    return mul(float4(worldPos, 1.0), LightViewProjectionMatrix).xyz;
}

#endif
